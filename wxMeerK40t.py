# -*- coding: ISO-8859-1 -*-
#
# generated by wxGlade 0.9.3 on Thu Jun 27 21:45:40 2019
#

import sys
import traceback

import wx
import wx.ribbon as RB

from Alignment import Alignment
from BufferView import BufferView
from ColorDefine import ColorDefine
from Controller import Controller
from DefaultModules import *
from ElementProperty import ElementProperty
from JobInfo import JobInfo
from JobSpooler import JobSpooler
from Kernel import *
from Keymap import Keymap
from LaserOperation import *
from LaserRender import LaserRender, swizzlecolor
from Navigation import Navigation
from Preferences import Preferences
from RotarySettings import RotarySettings
from UsbConnect import UsbConnect
from ZMatrix import ZMatrix
from icons import *
from svgelements import *

try:
    from math import tau
except ImportError:
    from math import pi

    tau = pi * 2

"""
Laser software for the Stock-LIHUIYU laserboard.

MeerK40t (pronounced MeerKat) is a built-from-the-ground-up MIT licensed 
open-source laser cutting software. See https://github.com/meerk40t/meerk40t
for full details.

"""

MILS_IN_MM = 39.3701
MEERK40T_VERSION = "0.4.0"
MEERK40T_ISSUES = "https://github.com/meerk40t/meerk40t/issues"
MEERK40T_WEBSITE = "https://github.com/meerk40t/meerk40t"


# begin wxGlade: dependencies
# end wxGlade

class IdInc:
    """
    Id Incrementor
    """

    def __init__(self):
        self.id_highest_value = wx.ID_HIGHEST

    def new(self):
        self.id_highest_value += 1
        return self.id_highest_value


idinc = IdInc()
ID_MAIN_TOOLBAR = idinc.new()
ID_ADD_FILE = idinc.new()
ID_OPEN = idinc.new()
ID_SAVE = idinc.new()
ID_NAV = idinc.new()
ID_USB = idinc.new()
ID_CONTROLLER = idinc.new()
ID_PREFERENCES = idinc.new()
ID_JOB = idinc.new()
ID_SPOOLER = idinc.new()

ID_CUT_CONFIGURATION = idinc.new()
ID_SELECT = idinc.new()

ID_MENU_NEW = idinc.new()
ID_MENU_OPEN_PROJECT = idinc.new()
ID_MENU_RECENT_PROJECT = idinc.new()

ID_MENU_IMPORT = idinc.new()
ID_MENU_SAVE = idinc.new()
ID_MENU_SAVE_AS = idinc.new()
ID_MENU_EXIT = idinc.new()
ID_MENU_ZOOM_OUT = idinc.new()
ID_MENU_ZOOM_IN = idinc.new()
ID_MENU_ZOOM_SIZE = idinc.new()

# 1 fill, 2 grids, 4 guides, 8 laserpath, 16 writer_position, 32 selection
ID_MENU_HIDE_FILLS = idinc.new()
ID_MENU_HIDE_GUIDES = idinc.new()
ID_MENU_HIDE_GRID = idinc.new()
ID_MENU_HIDE_STROKES = idinc.new()
ID_MENU_HIDE_LASERPATH = idinc.new()
ID_MENU_HIDE_RETICLE = idinc.new()
ID_MENU_HIDE_SELECTION = idinc.new()
ID_MENU_SCREEN_REFRESH = idinc.new()
ID_MENU_SCREEN_ANIMATE = idinc.new()
ID_MENU_HIDE_IMAGE = idinc.new()
ID_MENU_HIDE_PATH = idinc.new()
ID_MENU_HIDE_TEXT = idinc.new()

ID_MENU_ALIGNMENT = idinc.new()
ID_MENU_KEYMAP = idinc.new()
ID_MENU_COLORDEFINE = idinc.new()
ID_MENU_PREFERENCES = idinc.new()
ID_MENU_ROTARY = idinc.new()
ID_MENU_NAVIGATION = idinc.new()
ID_MENU_CONTROLLER = idinc.new()
ID_MENU_USB = idinc.new()
ID_MENU_SPOOLER = idinc.new()
ID_MENU_JOB = idinc.new()
ID_MENU_TREE = idinc.new()

ID_MENU_WEBPAGE = idinc.new()
ID_CUT_TREE = idinc.new()
ID_CUT_BURN_BUTTON = idinc.new()

_ = wx.GetTranslation
supported_languages = (('en', u'English', wx.LANGUAGE_ENGLISH),
                       ('fr', u'français', wx.LANGUAGE_FRENCH),
                       ('de', u'Deutsch', wx.LANGUAGE_GERMAN),
                       ('es', u'español', wx.LANGUAGE_SPANISH))


class MeerK40t(wx.Frame):
    """
    MeerK40t main window
    """

    def __init__(self, *args, **kwds):
        # begin wxGlade: MeerK40t.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        self.DragAcceptFiles(True)

        self.tree = wx.TreeCtrl(self, wx.ID_ANY, style=wx.TR_MULTIPLE | wx.TR_HIDE_ROOT)  # wx.FULL_REPAINT_ON_RESIZE |
        self.tree_images = wx.ImageList()
        self.tree_images.Create(width=20, height=20)
        self.tree.SetImageList(self.tree_images)
        self.scene = wx.Panel(self, style=wx.EXPAND | wx.WANTS_CHARS)
        self.scene.SetDoubleBuffered(True)

        self._ribbon = RB.RibbonBar(self, style=RB.RIBBON_BAR_DEFAULT_STYLE
                                                | RB.RIBBON_BAR_SHOW_PANEL_EXT_BUTTONS)

        home = RB.RibbonPage(self._ribbon, wx.ID_ANY, _("Examples"), icons8_opened_folder_50.GetBitmap())
        toolbar_panel = RB.RibbonPanel(home, wx.ID_ANY, _("Toolbar"),
                                       style=RB.RIBBON_PANEL_NO_AUTO_MINIMISE | RB.RIBBON_PANEL_EXT_BUTTON)

        toolbar = RB.RibbonToolBar(toolbar_panel, ID_MAIN_TOOLBAR)
        self.toolbar = toolbar

        toolbar.AddTool(ID_OPEN, icons8_opened_folder_50.GetBitmap(), "")  # "Open",
        toolbar.AddTool(ID_SAVE, icons8_save_50.GetBitmap(), "")
        toolbar.AddTool(ID_JOB, icons8_laser_beam_52.GetBitmap(), "")

        windows_panel = RB.RibbonPanel(home, wx.ID_ANY, _("Windows"), icons8_opened_folder_50.GetBitmap())
        windows = RB.RibbonButtonBar(windows_panel)
        windows.AddButton(ID_NAV, _("Navigation"), icons8_move_32.GetBitmap(), "")
        windows.AddButton(ID_USB, _("Usb"), icons8_usb_connector_50.GetBitmap(), "")
        windows.AddButton(ID_SPOOLER, _("Spooler"), icons8_route_50.GetBitmap(), "")
        windows.AddButton(ID_CONTROLLER, _("Controller"), icons8_connected_50.GetBitmap(), "")
        windows.AddButton(ID_PREFERENCES, _("Preferences"), icons8_administrative_tools_50.GetBitmap(), "")
        self._ribbon.Realize()

        self.CenterOnScreen()
        # Menu Bar
        self.main_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_MENU_NEW, _("New"), "")
        wxglade_tmp_menu.Append(ID_MENU_OPEN_PROJECT, _("Open Project"), "")
        wxglade_tmp_menu.Append(ID_MENU_IMPORT, _("Import File"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_SAVE, _("Save"), "")
        wxglade_tmp_menu.Append(ID_MENU_SAVE_AS, _("Save As"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_EXIT, _("Exit"), "")
        self.main_menubar.Append(wxglade_tmp_menu, _("File"))
        wxglade_tmp_menu = wx.Menu()

        wxglade_tmp_menu.Append(ID_MENU_ZOOM_OUT, _("Zoom Out"), "")
        wxglade_tmp_menu.Append(ID_MENU_ZOOM_IN, _("Zoom In"), "")
        wxglade_tmp_menu.Append(ID_MENU_ZOOM_SIZE, _("Zoom To Size"), "")
        wxglade_tmp_menu.AppendSeparator()
        wxglade_tmp_menu.Append(ID_MENU_HIDE_GRID, _("Hide Grid"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_GUIDES, _("Hide Guides"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_PATH, _("Hide Paths"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_IMAGE, _("Hide Images"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_TEXT, _("Hide Text"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_FILLS, _("Hide Fills"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_STROKES, _("Hide Strokes"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_LASERPATH, _("Hide Laserpath"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_RETICLE, _("Hide Reticle"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_HIDE_SELECTION, _("Hide Selection"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_SCREEN_REFRESH, _("Do Not Refresh"), "", wx.ITEM_CHECK)
        wxglade_tmp_menu.Append(ID_MENU_SCREEN_ANIMATE, _("Do Not Animate"), "", wx.ITEM_CHECK)
        self.main_menubar.Append(wxglade_tmp_menu, _("View"))
        wxglade_tmp_menu = wx.Menu()

        wxglade_tmp_menu.Append(ID_MENU_PREFERENCES, _("Preferences"), "")
        wxglade_tmp_menu.Append(ID_MENU_ROTARY, _("Rotary Settings"), "")
        wxglade_tmp_menu.Append(ID_MENU_KEYMAP, _("Keymap Settings"), "")
        # wxglade_tmp_menu.Append(ID_MENU_COLORDEFINE, "Color Define", "")
        wxglade_tmp_menu.Append(ID_MENU_ALIGNMENT, _("Alignment Ally"), "")

        wxglade_tmp_menu.Append(ID_MENU_NAVIGATION, _("Navigation"), "")
        wxglade_tmp_menu.Append(ID_MENU_CONTROLLER, _("Controller"), "")
        wxglade_tmp_menu.Append(ID_MENU_USB, _("USB"), "")
        wxglade_tmp_menu.Append(ID_MENU_SPOOLER, _("Job Spooler"), "")
        wxglade_tmp_menu.Append(ID_MENU_JOB, _("Execute Job"), "")

        self.main_menubar.Append(wxglade_tmp_menu, _("Windows"))

        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(ID_MENU_WEBPAGE, _("Webpage"), "")
        self.main_menubar.Append(wxglade_tmp_menu, _("Help"))

        self.SetMenuBar(self.main_menubar)
        # Menu Bar end

        self.Bind(wx.EVT_MENU, self.on_click_new, id=ID_MENU_NEW)
        self.Bind(wx.EVT_MENU, self.on_click_open, id=ID_MENU_OPEN_PROJECT)
        self.Bind(wx.EVT_MENU, self.on_click_open, id=ID_MENU_IMPORT)
        self.Bind(wx.EVT_MENU, self.on_click_save, id=ID_MENU_SAVE)
        self.Bind(wx.EVT_MENU, self.on_click_save_as, id=ID_MENU_SAVE_AS)

        self.Bind(wx.EVT_MENU, self.on_click_exit, id=ID_MENU_EXIT)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_out, id=ID_MENU_ZOOM_OUT)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_in, id=ID_MENU_ZOOM_IN)
        self.Bind(wx.EVT_MENU, self.on_click_zoom_size, id=ID_MENU_ZOOM_SIZE)

        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0004), id=ID_MENU_HIDE_GRID)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0002), id=ID_MENU_HIDE_GUIDES)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0400), id=ID_MENU_HIDE_PATH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0800), id=ID_MENU_HIDE_IMAGE)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x1000), id=ID_MENU_HIDE_TEXT)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0001), id=ID_MENU_HIDE_FILLS)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0008), id=ID_MENU_HIDE_LASERPATH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0010), id=ID_MENU_HIDE_RETICLE)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0020), id=ID_MENU_HIDE_SELECTION)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0040), id=ID_MENU_HIDE_STROKES)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0100), id=ID_MENU_SCREEN_REFRESH)
        self.Bind(wx.EVT_MENU, self.toggle_draw_mode(0x0200), id=ID_MENU_SCREEN_ANIMATE)

        self.Bind(wx.EVT_MENU, self.open_alignment, id=ID_MENU_ALIGNMENT)
        self.Bind(wx.EVT_MENU, self.open_keymap, id=ID_MENU_KEYMAP)
        # self.Bind(wx.EVT_MENU, self.open_colordefine, id=ID_MENU_COLORDEFINE)
        self.Bind(wx.EVT_MENU, self.open_preferences, id=ID_MENU_PREFERENCES)
        self.Bind(wx.EVT_MENU, self.open_rotary, id=ID_MENU_ROTARY)
        self.Bind(wx.EVT_MENU, self.open_navigation, id=ID_MENU_NAVIGATION)
        self.Bind(wx.EVT_MENU, self.open_controller, id=ID_MENU_CONTROLLER)
        self.Bind(wx.EVT_MENU, self.open_usb, id=ID_MENU_USB)
        self.Bind(wx.EVT_MENU, self.open_spooler, id=ID_MENU_SPOOLER)
        self.Bind(wx.EVT_MENU, self.open_job, id=ID_MENU_JOB)

        self.Bind(wx.EVT_MENU, self.launch_webpage, id=ID_MENU_WEBPAGE)

        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.on_click_open, id=ID_OPEN)
        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.on_click_save, id=ID_SAVE)
        toolbar.Bind(RB.EVT_RIBBONTOOLBAR_CLICKED, self.open_job, id=ID_JOB)

        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_usb, id=ID_USB)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_navigation, id=ID_NAV)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_controller, id=ID_CONTROLLER)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_preferences, id=ID_PREFERENCES)
        windows.Bind(RB.EVT_RIBBONBUTTONBAR_CLICKED, self.open_spooler, id=ID_SPOOLER)

        self.main_statusbar = self.CreateStatusBar(3)

        # end wxGlade

        self.Bind(wx.EVT_DROP_FILES, self.on_drop_file)

        self.previous_position = None

        self.Bind(wx.EVT_TREE_BEGIN_DRAG, self.on_drag_begin_handler, self.tree)
        self.Bind(wx.EVT_TREE_END_DRAG, self.on_drag_end_handler, self.tree)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_item_activated, self.tree)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_item_changed, self.tree)
        self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.on_item_right_click, self.tree)
        # end wxGlade
        # self.Bind(wx.EVT_BUTTON, self.on_clicked_burn, id=ID_CUT_BURN_BUTTON)

        # end wxGlade
        self.dragging_element = None
        self.dragging_parent = None
        # self.SetDoubleBuffered(True)

        self.matrix = ZMatrix()
        self.identity = ZMatrix()
        self.matrix.Reset()
        self.identity.Reset()
        self.previous_window_position = None
        self.previous_scene_position = None
        self.popup_window_position = None
        self.popup_scene_position = None
        self._Buffer = None
        self.screen_refresh_is_requested = True
        self.screen_refresh_is_running = False
        self.background_brush = wx.Brush("Grey")
        self.renderer = None
        self.grid = None
        self.guide_lines = None
        self.laserpath = [(0, 0, 0, 0)] * 1000
        self.laserpath_index = 0
        self.move_function = self.move_pan
        self.working_file = None

        self.__set_properties()
        self.__do_layout()

        self.set_buffer()

        self.selection_pen = wx.Pen()
        self.selection_pen.SetColour(wx.BLUE)
        self.selection_pen.SetWidth(25)
        self.selection_pen.SetStyle(wx.PENSTYLE_SHORT_DASH)

        self.scene.Bind(wx.EVT_PAINT, self.on_paint)
        self.scene.Bind(wx.EVT_ERASE_BACKGROUND, self.on_erase)

        self.scene.Bind(wx.EVT_MOTION, self.on_mouse_move)

        self.scene.Bind(wx.EVT_MOUSEWHEEL, self.on_mousewheel)

        self.scene.Bind(wx.EVT_MIDDLE_DOWN, self.on_mouse_middle_down)
        self.scene.Bind(wx.EVT_MIDDLE_UP, self.on_mouse_middle_up)

        self.scene.Bind(wx.EVT_LEFT_DCLICK, self.on_mouse_double_click)

        self.scene.Bind(wx.EVT_RIGHT_DOWN, self.on_right_mouse_down)
        self.scene.Bind(wx.EVT_RIGHT_UP, self.on_right_mouse_up)

        self.scene.Bind(wx.EVT_LEFT_DOWN, self.on_left_mouse_down)
        self.scene.Bind(wx.EVT_LEFT_UP, self.on_left_mouse_up)

        self.scene.Bind(wx.EVT_ENTER_WINDOW, lambda event: self.scene.SetFocus())  # Focus follows mouse.
        self.tree.Bind(wx.EVT_ENTER_WINDOW, lambda event: self.tree.SetFocus())  # Focus follows mouse.
        self.scene.Bind(wx.EVT_KEY_DOWN, self.on_key_press)

        self.Bind(wx.EVT_CLOSE, self.on_close, self)

        self.fps_job = None
        self.kernel = None
        self.backend_listening = None

    def add_language_menu(self):
        if os.path.exists('./locale'):
            wxglade_tmp_menu = wx.Menu()
            i = 0
            for lang in supported_languages:
                language_code, language_name, language_index = lang
                m = wxglade_tmp_menu.Append(wx.ID_ANY, language_name, "", wx.ITEM_RADIO)
                if i == self.kernel.language:
                    m.Check(True)
                self.Bind(wx.EVT_MENU, self.language_to(i), id=m.GetId())
                if not os.path.exists('./locale/%s' % language_code) and i != 0:
                    m.Enable(False)
                i += 1
            self.main_menubar.Append(wxglade_tmp_menu, _("Languages"))

    def set_kernel(self, kernel):
        self.kernel = kernel
        kernel.setting(int, "draw_mode", 0)  # 1 fill, 2 grids, 4 guides, 8 laserpath, 16 writer_position, 32 selection
        kernel.setting(int, "window_width", 1200)
        kernel.setting(int, "window_height", 600)
        kernel.setting(int, "bed_width", 320)
        kernel.setting(int, "bed_height", 220)
        kernel.setting(float, "units_convert", 39.37)
        kernel.setting(str, "units_name", 'mm')
        kernel.setting(int, "units_marks", 10)
        kernel.setting(int, "units_index", 0)
        kernel.setting(bool, "mouse_zoom_invert", False)
        kernel.setting(int, "_stepping_force", None)
        kernel.setting(int, 'fps', 40)
        kernel.setting(float, "current_x", 0.0)
        kernel.setting(float, "current_y", 0.0)

        self.kernel.listen("elements", self.on_elements_update)
        self.kernel.listen("elements", self.elements_changed)
        self.kernel.listen("units", self.space_changed)
        self.kernel.listen("selection", self.selection_changed)
        self.kernel.listen("bed_size", self.bed_changed)
        self.listen_backend(self.kernel.backend)
        if kernel.fps <= 0:
            kernel.fps = 60
        self.renderer = LaserRender(kernel)

        if kernel.window_width < 300:
            kernel.window_width = 300
        if kernel.window_height < 300:
            kernel.window_height = 300

        kernel.add_control("Path", self.open_path_dialog)
        kernel.add_control("FPS", self.open_fps_dialog)
        kernel.add_control("Speedcode-Gear-Force", self.open_speedcode_gear_dialog)

        self.SetSize((kernel.window_width, kernel.window_height))
        bedwidth = kernel.bed_width
        bedheight = kernel.bed_height

        self.kernel.boot()
        self.focus_viewport_scene((0, 0, bedwidth * MILS_IN_MM, bedheight * MILS_IN_MM), 0.1)
        self.fps_job = self.kernel.cron.add_job(self.refresh_scene, interval=1.0 / float(kernel.fps))
        self.add_language_menu()
        self.kernel.elements_change_listener = self.tree_update

        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_FILLS)
        m.Check(self.kernel.draw_mode & 0x0001 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_GUIDES)
        m.Check(self.kernel.draw_mode & 0x0002 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_GRID)
        m.Check(self.kernel.draw_mode & 0x0004 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_LASERPATH)
        m.Check(self.kernel.draw_mode & 0x0008 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_RETICLE)
        m.Check(self.kernel.draw_mode & 0x0010 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_SELECTION)
        m.Check(self.kernel.draw_mode & 0x0020 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_STROKES)
        m.Check(self.kernel.draw_mode & 0x0040 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_SCREEN_REFRESH)
        m.Check(self.kernel.draw_mode & 0x0100 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_SCREEN_ANIMATE)
        m.Check(self.kernel.draw_mode & 0x0200 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_PATH)
        m.Check(self.kernel.draw_mode & 0x0400 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_IMAGE)
        m.Check(self.kernel.draw_mode & 0x0800 != 0)
        m = self.GetMenuBar().FindItemById(ID_MENU_HIDE_TEXT)
        m.Check(self.kernel.draw_mode & 0x1000 != 0)
        self.refresh_tree_elements()
        self.on_size(None)
        self.Bind(wx.EVT_SIZE, self.on_size)
        self.space_changed(0)
        self.default_keymap()

    def set_fps(self, fps):
        if fps == 0:
            fps = 1
        self.fps_job.times = 0
        self.kernel.fps = fps
        self.fps_job = self.kernel.cron.add_job(self.refresh_scene, interval=1.0 / float(self.kernel.fps))

    def on_elements_update(self, *args):
        """
        Called by 'elements' change. To refresh tree.

        :param args:
        :return:
        """
        self.refresh_tree_elements()

    def on_drag_begin_handler(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Drag handler begin for the tree.

        :param event:
        :return:
        """
        self.dragging_element = None
        self.dragging_parent = None
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        if element is self.kernel.operations or element is self.kernel.elements:
            event.Skip()
            return
        self.dragging_parent = self.tree.GetItemParent(item)
        self.dragging_parent = self.tree.GetItemData(self.dragging_parent)
        self.dragging_element = element
        event.Allow()

    def on_drag_end_handler(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Drag handler end for the tree

        :param event:
        :return:
        """
        if self.dragging_element is None:
            event.Skip()
            return
        drag_element = self.dragging_element
        drag_parent = self.dragging_parent
        self.dragging_element = None
        self.dragging_parent = None

        e = event.GetItem()
        if e is None:
            event.Skip()
            return
        if e.ID is None:
            event.Skip()
            return
        drop_element = self.tree.GetItemData(e)
        if drop_element is None or drop_element == drag_element:
            event.Skip()
            return
        if drag_element is self.kernel.operations:
            event.Skip()
            return
        if drag_element is self.kernel.elements:
            event.Skip()
            return
        if isinstance(drag_element, LaserNode):
            if drop_element is self.kernel.operations:
                self.kernel.classify(drag_element)
                event.Allow()
                self.refresh_tree_elements()
                return
            elif isinstance(drop_element, LaserOperation):
                if isinstance(drop_element, EngraveOperation) and drag_element.type == 'image':
                    event.Skip()
                    self.kernel.signal("Error", "Cannot add image to engrave operation.")
                    return
                drop_element.append(drag_element.element)
                event.Allow()
                self.refresh_tree_elements()
                return
            elif isinstance(drop_element, LaserNode):
                if drop_element.type == 'root':  # Project
                    drag_parent.remove(drag_element)
                    if len(drag_parent) == 0 and drag_parent.type == 'group' and drag_parent.name is None:
                        drag_parent.parent.remove(drag_parent)

                    if drag_element.type != 'group':
                        group = LaserNode()
                        group.append(drag_element)
                        group.update(drag_element)  # Group gets element property.
                        drop_element.append(group)
                    else:
                        drop_element.append(drag_element)
                    event.Allow()
                    return
                if drop_element.type == 'group':  # Group
                    drag_parent.remove(drag_element)
                    if len(drag_parent) == 0 and drag_parent.type == 'group' and drag_parent.name is None:
                        drag_parent.parent.remove(drag_parent)
                    drop_element.append(drag_element)
                    event.Allow()
                    return
        elif isinstance(drag_element, LaserOperation):
            if drop_element is self.kernel.operations:
                self.kernel.operations.remove(drag_element)
                self.kernel.operations.append(drag_element)
                event.Allow()
                self.refresh_tree_elements()
                return
        event.Skip()

    def on_item_right_click(self, event):
        """
        Right click of element in tree.

        :param event:
        :return:
        """
        item = event.GetItem()
        if item is None:
            return
        if item.ID is None:
            return
        element = self.tree.GetItemData(item)
        if element is not None:
            self.kernel.set_selected(element)
            self.create_menu(element)
        event.Skip()

    def on_item_activated(self, event):  # wxGlade: CutConfiguration.<event_handler>
        """
        Tree item is double-clicked. Launches ElementProperty dialog.

        :param event:
        :return:
        """
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        if element is not None:
            if isinstance(element, LaserNode) or isinstance(element, LaserOperation):
                self.kernel.open_window("ElementProperty").set_elements(element)

    def on_item_changed(self, event):
        """
        Tree menu item is changed. Modify the selection.

        :param event:
        :return:
        """
        item = event.GetItem()
        element = self.tree.GetItemData(item)
        if element is not None:
            self.kernel.set_selected(element)

    def add_element(self, tree, node, element):
        """
        Add a element to the tree.

        :param tree:
        :param node:
        :param element:
        :return:
        """
        if isinstance(element, LaserOperation):
            item = tree.AppendItem(node, str(element))
            tree.SetItemData(item, element)
            for subitem in element:
                self.add_element(tree, item, subitem)
        elif isinstance(element, SVGElement):
            item = tree.AppendItem(node, str(element))
            tree.SetItemData(item, element)
        elif isinstance(element, LaserNode):
            if element.passes == 1 or element.passes is None:
                item = tree.AppendItem(node, str(element))
            else:
                print(element.passes)
                item = tree.AppendItem(node, "%s pass, %s" % (str(element.passes), str(element)))
            tree.SetItemData(item, element)
            try:
                tree.SetItemBackgroundColour(item, wx.Colour(swizzlecolor(element.fill)))
            except AttributeError:
                pass
            try:
                tree.SetItemTextColour(item, wx.Colour(swizzlecolor(element.stroke)))
            except AttributeError:
                pass
            t = element.type
            if t == 'image':
                image = self.renderer.make_thumbnail(element, width=20, height=20)
            else:
                image = self.renderer.make_raster(element, width=20, height=20, bitmap=True)
            if image is not None:
                id = self.tree_images.Add(bitmap=image)
                tree.SetItemImage(item, image=id)
            for subitem in element:
                self.add_element(tree, item, subitem)
        else:
            print(element)

    def refresh_tree_elements(self):
        """
        Rebuild tree elements

        :return:
        """
        tree = self.tree
        tree.DeleteAllItems()
        root = self.tree.AddRoot("Root")
        operations = tree.AppendItem(root, "Operations")
        self.tree.SetItemData(root, self.kernel.operations)

        self.tree.SetItemData(operations, self.kernel.operations)
        for subitem in self.kernel.operations:
            self.add_element(tree, operations, subitem)

        elements = tree.AppendItem(root, "Elements")
        self.tree.SetItemData(elements, self.kernel.elements)
        for subitem in self.kernel.elements:
            self.add_element(tree, elements, subitem)

        tree.CollapseAll()
        tree.ExpandAll()

    def on_usb_status(self, value):
        self.main_statusbar.SetStatusText(_("Usb: %s" % value), 0)

    def on_control_state(self, value):
        self.main_statusbar.SetStatusText(_("Controller: %s" % self.kernel.get_state_string_from_state(value)), 1)

    def on_writer_state(self, value):
        self.main_statusbar.SetStatusText(_("Spooler: %s" % self.kernel.get_state_string_from_state(value)), 2)

    def on_writer_mode(self, state):
        if state == 0:
            self.background_brush = wx.Brush("Grey")
        else:
            self.background_brush = wx.Brush("Red")
        self.request_refresh_for_animation()

    def listen_backend(self, backend):
        if self.backend_listening is not None:
            self.unlisten_backend()
        self.backend_listening = backend
        uid = backend.uid
        self.kernel.listen("%s;pipe;usb" % uid, self.on_usb_status)
        self.kernel.listen("%s;pipe;thread" % uid, self.on_control_state)
        self.kernel.listen("%s;interpreter;state" % uid, self.on_writer_state)
        self.kernel.listen("%s;interpreter;position" % uid, self.update_position)
        self.kernel.listen("%s;interpreter;mode" % uid, self.on_writer_mode)

    def unlisten_backend(self):
        if self.backend_listening is None:
            return # Can't unlisten to nothing, ---
        backend = self.backend_listening
        uid = backend.uid
        self.kernel.unlisten("%s;pipe;usb" % uid, self.on_usb_status)
        self.kernel.unlisten("%s;pipe;thread" % uid, self.on_control_state)
        self.kernel.unlisten("%s;interpreter;state" % uid, self.on_writer_state)
        self.kernel.unlisten("%s;interpreter;position" % uid, self.update_position)
        self.kernel.unlisten("%s;interpreter;mode" % uid, self.on_writer_mode)


    def on_close(self, event):
        # TODO: This model is outdated for version 4.
        # There could be several backends that are equally running.
        if self.kernel.backend.spooler.thread.state == THREAD_STATE_STARTED or \
                self.kernel.backend.pipe.thread.state == THREAD_STATE_STARTED:
            dlg = wx.MessageDialog(None, _("Issue emergency stop and close?"),
                                   _('Processes are still running.'), wx.OK | wx.CANCEL | wx.ICON_WARNING)
            result = dlg.ShowModal()
            dlg.Destroy()

            if result == wx.ID_OK:
                pass
            else:
                return
        for window in [value for key, value in self.kernel.open_windows.items()]:
            window.Close()
        self.kernel.unlisten("usb_state", self.on_usb_status)
        self.kernel.unlisten("control_thread", self.on_control_state)
        self.kernel.unlisten("writer", self.on_writer_state)
        self.kernel.flush()
        self.kernel.unlisten("position", self.update_position)
        self.kernel.unlisten("units", self.space_changed)
        self.kernel.unlisten("selection", self.selection_changed)
        self.kernel.unlisten("bed_size", self.bed_changed)
        self.kernel.unlisten("elements", self.elements_changed)
        self.kernel.shutdown()
        event.Skip()  # Call destroy as regular.

    def __set_properties(self):
        # begin wxGlade: MeerK40t.__set_properties
        self.SetTitle(_("MeerK40t v%s" % MEERK40T_VERSION))
        self.main_statusbar.SetStatusWidths([-1] * self.main_statusbar.GetFieldsCount())
        _icon = wx.NullIcon
        _icon.CopyFromBitmap(icon_meerk40t.GetBitmap())
        self.SetIcon(_icon)
        # statusbar fields
        main_statusbar_fields = ["Status"]
        for i in range(len(main_statusbar_fields)):
            self.main_statusbar.SetStatusText(main_statusbar_fields[i], i)
        # self.main_toolbar.Realize()

        # self.scene.SetMinSize((1000, 880))
        # self.scene.SetBackgroundColour(wx.Colour(200,200,200))
        # end wxGlade

    def __do_layout(self):
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        main_sizer.Add(self._ribbon, 1, wx.EXPAND, 0)
        widget_sizer = wx.BoxSizer(wx.HORIZONTAL)
        widget_sizer.Add(self.tree, 1, wx.EXPAND, 0)
        widget_sizer.Add(self.scene, 5, wx.ALL | wx.EXPAND, 2)
        main_sizer.Add(widget_sizer, 5, wx.EXPAND, 0)
        self.SetSizer(main_sizer)
        # main_sizer.Fit(self)
        self.Layout()

    def on_drop_file(self, event):
        """
        Drop file handler

        Accepts multiple files drops.
        """
        accepted = 0
        rejected = 0
        rejected_files = []
        for pathname in event.GetFiles():
            result = self.kernel.load(pathname)
            if result is not None:
                self.kernel.classify(result)
                accepted += 1
            else:
                rejected += 1
                rejected_files.append(pathname)
        if rejected != 0:
            reject = "\n".join(rejected_files)
            err_msg = _("Some files were unrecognized:\n%s" % reject)
            dlg = wx.MessageDialog(None, err_msg, _('Error encountered'), wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()
        self.refresh_tree_elements()

    def tree_update(self):
        self.refresh_tree_elements()

    def on_paint(self, event):
        try:
            wx.BufferedPaintDC(self.scene, self._Buffer)
        except RuntimeError:
            pass

    def set_buffer(self):
        width, height = self.scene.ClientSize
        if width <= 0:
            width = 1
        if height <= 0:
            height = 1
        self._Buffer = wx.Bitmap(width, height)

    def on_size(self, event):
        self.Layout()
        self.set_buffer()
        self.kernel.window_width, self.kernel.window_height = self.Size
        self.guide_lines = None
        self.request_refresh()

    def update_position(self, pos):
        self.laserpath[self.laserpath_index] = pos
        self.laserpath_index += 1
        self.laserpath_index %= len(self.laserpath)
        self.request_refresh_for_animation()

    def space_changed(self, units):
        self.grid = None
        self.on_size(None)

    def bed_changed(self, size):
        self.grid = None
        self.on_size(None)

    def selection_changed(self, selection):
        self.request_refresh()

    def elements_changed(self, e):
        self.request_refresh()

    def on_erase(self, event):
        pass

    def request_refresh_for_animation(self):
        """Called on the various signals trying to animate the screen."""
        if self.kernel.draw_mode & 0x0200 == 0:
            self.request_refresh()

    def request_refresh(self):
        """Request an update to the scene."""
        if self.kernel.draw_mode & 0x0100 == 0:
            self.screen_refresh_is_requested = True

    def refresh_scene(self):
        """Called by the Scheduler at a given the specified framerate."""
        if self.screen_refresh_is_requested and not self.screen_refresh_is_running:
            self.screen_refresh_is_running = True
            wx.CallAfter(self.refresh_in_ui)

    def refresh_in_ui(self):
        """Called by refresh_scene() in the UI thread."""
        self.update_buffer_ui_thread()
        self.Refresh()
        self.screen_refresh_is_requested = False
        self.screen_refresh_is_running = False

    def update_buffer_ui_thread(self):
        """Performs the redraw of the data in the UI thread."""
        dc = wx.MemoryDC()
        dc.SelectObject(self._Buffer)
        self.on_draw_background(dc)
        if dc.CanUseTransformMatrix():
            dc.SetTransformMatrix(self.matrix)
            self.on_draw_scene(dc)
            dc.SetTransformMatrix(self.identity)
        else:
            original_font = dc.GetFont()
            font = wx.Font(20, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_LIGHT)
            dc.SetFont(font)
            dc.SetPen(wx.BLACK_PEN)
            s = dc.GetSize() / 2
            dc.DrawText(_("Current OS cannot use transformation matrix. Skipping scene draw."), s[0] - 350, s[1])
            dc.SetFont(original_font)
        self.on_draw_interface(dc)
        del dc

    def on_matrix_change(self):
        self.guide_lines = None

    def scene_matrix_reset(self):
        self.matrix.Reset()
        self.on_matrix_change()

    def scene_post_scale(self, sx, sy=None, ax=0, ay=0):
        self.matrix.PostScale(sx, sy, ax, ay)
        self.on_matrix_change()

    def scene_post_pan(self, px, py):
        self.matrix.PostTranslate(px, py)
        self.on_matrix_change()

    def scene_post_rotate(self, angle, rx=0, ry=0):
        self.matrix.PostRotate(angle, rx, ry)
        self.on_matrix_change()

    def scene_pre_scale(self, sx, sy=None, ax=0, ay=0):
        self.matrix.PreScale(sx, sy, ax, ay)
        self.on_matrix_change()

    def scene_pre_pan(self, px, py):
        self.matrix.PreTranslate(px, py)
        self.on_matrix_change()

    def scene_pre_rotate(self, angle, rx=0, ry=0):
        self.matrix.PreRotate(angle, rx, ry)
        self.on_matrix_change()

    def get_scale_x(self):
        return self.matrix.GetScaleX()

    def get_scale_y(self):
        return self.matrix.GetScaleY()

    def get_skew_x(self):
        return self.matrix.GetSkewX()

    def get_skew_y(self):
        return self.matrix.GetSkewY()

    def get_translate_x(self):
        return self.matrix.GetTranslateX()

    def get_translate_y(self):
        return self.matrix.GetTranslateY()

    def on_mousewheel(self, event):
        rotation = event.GetWheelRotation()
        mouse = event.GetPosition()
        if self.kernel.mouse_zoom_invert:
            rotation = -rotation
        if rotation > 1:
            self.scene_post_scale(1.1, 1.1, mouse[0], mouse[1])
        elif rotation < -1:
            self.scene_post_scale(0.9, 0.9, mouse[0], mouse[1])
        self.request_refresh()

    def on_mouse_middle_down(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        self.scene.CaptureMouse()
        self.previous_window_position = event.GetPosition()
        self.previous_scene_position = self.convert_window_to_scene(self.previous_window_position)

    def on_mouse_middle_up(self, event):
        if self.scene.HasCapture():
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.scene.ReleaseMouse()
        self.previous_window_position = None
        self.previous_scene_position = None

    def on_left_mouse_down(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        self.scene.CaptureMouse()
        self.previous_window_position = event.GetPosition()
        self.previous_scene_position = self.convert_window_to_scene(self.previous_window_position)
        self.renderer.set_selected_by_position(self.previous_scene_position)
        self.move_function = self.move_selected

    def on_left_mouse_up(self, event):
        if self.scene.HasCapture():
            self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))
            self.scene.ReleaseMouse()
        self.previous_window_position = None
        self.previous_scene_position = None
        self.move_function = self.move_pan
        self.renderer.validate()

    def on_mouse_double_click(self, event):
        position = event.GetPosition()
        position = self.convert_window_to_scene(position)
        self.renderer.set_selected_by_position(position)
        if self.kernel.selected is not None:
            window = self.kernel.open_window("ElementProperty")
            window.set_elements(self.kernel.selected)

    def move_pan(self, wdx, wdy, sdx, sdy):
        self.scene_post_pan(wdx, wdy)
        self.request_refresh()

    def move_selected(self, wdx, wdy, sdx, sdy):
        self.kernel.move_selected(sdx, sdy)
        self.request_refresh()

    def on_mouse_move(self, event):
        if not event.Dragging():
            return
        else:
            self.SetCursor(wx.Cursor(wx.CURSOR_HAND))
        if self.previous_window_position is None:
            return

        pos = event.GetPosition()
        window_position = pos.x, pos.y
        scene_position = self.convert_window_to_scene([window_position[0], window_position[1]])
        sdx = (scene_position[0] - self.previous_scene_position[0])
        sdy = (scene_position[1] - self.previous_scene_position[1])
        wdx = (window_position[0] - self.previous_window_position[0])
        wdy = (window_position[1] - self.previous_window_position[1])
        self.move_function(wdx, wdy, sdx, sdy)
        self.previous_window_position = window_position
        self.previous_scene_position = scene_position

    def on_right_mouse_down(self, event):
        self.popup_window_position = event.GetPosition()
        self.popup_scene_position = self.convert_window_to_scene(self.popup_window_position)
        self.renderer.set_selected_by_position(self.popup_scene_position)
        self.create_menu(self.kernel.selected)

    def on_right_mouse_up(self, event):
        self.SetCursor(wx.Cursor(wx.CURSOR_ARROW))

    def default_keymap(self):
        self.kernel.keymap[wx.WXK_RIGHT] = MappedKey("right", "move right 1mm")
        self.kernel.keymap[wx.WXK_LEFT] = MappedKey("left", "move left 1mm")
        self.kernel.keymap[wx.WXK_UP] = MappedKey("up", "move up 1mm")
        self.kernel.keymap[wx.WXK_DOWN] = MappedKey("down", "move down 1mm")
        self.kernel.keymap[ord('1')] = MappedKey('1', "set_position 1")
        self.kernel.keymap[ord('2')] = MappedKey('2', "set_position 2")
        self.kernel.keymap[ord('3')] = MappedKey('3', "set_position 3")
        self.kernel.keymap[ord('4')] = MappedKey('4', "set_position 4")
        self.kernel.keymap[ord('5')] = MappedKey('5', "set_position 5")
        self.kernel.keymap[wx.WXK_F6] = MappedKey('F6', "window JobSpooler")
        self.kernel.keymap[wx.WXK_F7] = MappedKey('F7', "window Controller")
        self.kernel.keymap[wx.WXK_F8] = MappedKey('F8', "control Path")

    def execute_string_action(self, action, *args):
        writer = self.kernel.spooler
        if action == 'move':
            writer.send_job(self.execute_move_action(*args))
        elif action == 'move_to':
            writer.send_job(self.execute_move_to_action(*args))
        elif action == 'set_position':
            self.execute_set_position_action(*args)
        elif action == 'window':
            self.execute_open_window_action(*args)
        elif action == 'control':
            self.execute_execute_control(*args)

    def execute_execute_control(self, *args):
        self.kernel.execute(args[0])

    def execute_open_window_action(self, *args):
        window_name = args[0]
        if window_name in self.kernel.windows:
            self.kernel.open_window(window_name)

    def execute_set_position_action(self, index):
        x = self.kernel.backend.current_x
        y = self.kernel.backend.current_y
        self.kernel.keymap[ord(index)] = MappedKey(index, "move_to %d %d" % (x, y))

    def execute_move_action(self, direction, amount):
        min_dim = min(self.kernel.window_width, self.kernel.window_height)
        amount = Length(amount).value(ppi=1000.0, relative_length=min_dim)
        x = 0
        y = 0
        if direction == 'right':
            x = amount
        elif direction == 'left':
            x = -amount
        elif direction == 'up':
            y = -amount
        elif direction == 'down':
            y = amount

        def move():
            yield COMMAND_SET_INCREMENTAL
            yield COMMAND_RAPID_MOVE, (x, y)
            yield COMMAND_SET_ABSOLUTE

        return move

    def execute_move_to_action(self, position_x, position_y):
        def move():
            yield COMMAND_RAPID_MOVE, (int(position_x), int(position_y))

        return move

    def on_key_press(self, event):
        keycode = event.GetKeyCode()
        if keycode in self.kernel.keymap:
            action = self.kernel.keymap[keycode].command
            args = str(action).split(' ')
            self.execute_string_action(*args)

    def focus_on_project(self):
        bbox = self.renderer.bbox(self.kernel.elements)
        if bbox is None:
            return
        self.focus_viewport_scene(bbox)
        self.request_refresh()

    def focus_position_scene(self, scene_point):
        window_width, window_height = self.scene.ClientSize
        scale_x = self.get_scale_x()
        scale_y = self.get_scale_y()
        self.scene_matrix_reset()
        self.scene_post_pan(-scene_point[0], -scene_point[1])
        self.scene_post_scale(scale_x, scale_y)
        self.scene_post_pan(window_width / 2.0, window_height / 2.0)

    def focus_viewport_scene(self, new_scene_viewport, buffer=0.0, lock=True):
        window_width, window_height = self.scene.ClientSize
        left = new_scene_viewport[0]
        top = new_scene_viewport[1]
        right = new_scene_viewport[2]
        bottom = new_scene_viewport[3]
        viewport_width = right - left
        viewport_height = bottom - top

        left -= viewport_width * buffer
        right += viewport_width * buffer
        top -= viewport_height * buffer
        bottom += viewport_height * buffer

        if right == left:
            scale_x = 100
        else:
            scale_x = window_width / float(right - left)
        if bottom == top:
            scale_y = 100
        else:
            scale_y = window_height / float(bottom - top)

        cx = ((right + left) / 2)
        cy = ((top + bottom) / 2)
        self.matrix.Reset()
        self.matrix.PostTranslate(-cx, -cy)
        if lock:
            scale = min(scale_x, scale_y)
            if scale != 0:
                self.matrix.PostScale(scale)
        else:
            if scale_x != 0 and scale_y != 0:
                self.matrix.PostScale(scale_x, scale_y)
        self.matrix.PostTranslate(window_width / 2.0, window_height / 2.0)

    def convert_scene_to_window(self, position):
        return self.matrix.TransformPoint([position[0], position[1]])

    def convert_window_to_scene(self, position):
        return self.matrix.InverseTransformPoint([position[0], position[1]])

    def calculate_grid(self):
        lines = []
        p = self.kernel
        wmils = p.bed_width * 39.37
        hmils = p.bed_height * 39.37
        convert = p.units_convert
        marks = p.units_marks
        step = convert * marks
        if step == 0:
            self.grid = []
            return
        x = 0.0
        while x < wmils:
            lines.append((x, 0, x, hmils))
            x += step
        y = 0.0
        while y < hmils:
            lines.append((0, y, wmils, y))
            y += step
        self.grid = lines

    def on_draw_grid(self, dc):
        if self.grid is None:
            self.calculate_grid()
        dc.DrawLineList(self.grid)

    def on_draw_guides(self, dc):
        lines = []
        w, h = self.Size
        p = self.kernel
        scaled_conversion = p.units_convert * self.matrix.GetScaleX()
        if scaled_conversion == 0:
            return

        wpoints = w / 15.0
        hpoints = h / 15.0
        points = min(wpoints, hpoints)
        # tweak the scaled points into being useful.
        # points = scaled_conversion * round(points / scaled_conversion * 10.0) / 10.0
        points = scaled_conversion * float('{:.1g}'.format(points / scaled_conversion))
        sx, sy = self.convert_scene_to_window([0, 0])
        if points == 0:
            return
        offset_x = sx % points
        offset_y = sy % points

        x = offset_x
        length = 50

        while x < w:
            lines.append((x, 0, x, length))
            lines.append((x, h, x, h - length))
            mark_point = (x - sx) / scaled_conversion
            if round(mark_point * 1000) == 0:
                mark_point = 0.0  # prevents -0
            dc.DrawRotatedText("%g %s" % (mark_point, p.units_name), x, 0, -90)
            x += points

        y = offset_y
        while y < h:
            lines.append((0, y, length, y))
            lines.append((w, y, w - length, y))
            mark_point = (y - sy) / scaled_conversion
            if round(mark_point * 1000) == 0:
                mark_point = 0.0  # prevents -0
            dc.DrawText("%g %s" % (mark_point + 0, p.units_name), 0, y + 0)
            y += points
        dc.DrawLineList(lines)

    def on_draw_background(self, dc):
        dc.SetBackground(self.background_brush)
        dc.Clear()

    def on_draw_interface(self, dc):
        pen = wx.Pen(wx.BLACK)
        pen.SetWidth(1)
        pen.SetCap(wx.CAP_BUTT)
        dc.SetPen(pen)
        if self.kernel.draw_mode & 2 == 0:
            self.on_draw_guides(dc)
        if self.kernel.draw_mode & 16 == 0:
            # Draw Reticle
            dc.SetPen(wx.RED_PEN)
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            try:
                x = self.kernel.backend.current_x
                y = self.kernel.backend.current_y
                x, y = self.convert_scene_to_window([x, y])
                dc.DrawCircle(x, y, 10)
            except AttributeError:
                pass

    def on_draw_bed(self, dc):
        wmils = self.kernel.bed_width * 39.37
        hmils = self.kernel.bed_height * 39.37
        dc.SetBrush(wx.WHITE_BRUSH)
        dc.DrawRectangle(0, 0, wmils, hmils)

    def on_draw_selection(self, dc, draw_mode):
        if self.kernel.selected is not None and self.kernel.selected.scene_bounds is not None:
            linewidth = 3.0 / self.matrix.GetScaleX()
            # f = 2 * linewidth
            # g = 2 * f
            self.selection_pen.SetWidth(linewidth)
            dc.SetPen(self.selection_pen)
            dc.SetBrush(wx.BLACK_BRUSH)
            x0, y0, x1, y1 = self.kernel.selected.scene_bounds
            center_x = (x0 + x1) / 2.0
            center_y = (y0 + y1) / 2.0
            dc.DrawLine(center_x, 0, center_x, y0)
            dc.DrawLine(0, center_y, x0, center_y)
            dc.DrawLine(x0, y0, x1, y0)
            dc.DrawLine(x1, y0, x1, y1)
            dc.DrawLine(x1, y1, x0, y1)
            dc.DrawLine(x0, y1, x0, y0)
            if draw_mode & 128 == 0:
                p = self.kernel
                conversion, name, marks, index = p.units_convert, p.units_name, p.units_marks, p.units_index
                dc.DrawText("%.1f%s" % (y0 / conversion, name), center_x, y0)
                dc.DrawText("%.1f%s" % (x0 / conversion, name), x0, center_y)
                dc.DrawText("%.1f%s" % ((y1 - y0) / conversion, name), x1, center_y)
                dc.DrawText("%.1f%s" % ((x1 - x0) / conversion, name), center_x, y1)

    def on_draw_laserpath(self, dc, draw_mode):
        dc.SetPen(wx.BLUE_PEN)
        dc.DrawLineList(self.laserpath)

    def on_draw_scene(self, dc):
        self.on_draw_bed(dc)
        dc.SetPen(wx.BLACK_PEN)
        if self.kernel.draw_mode & 4 == 0:
            self.on_draw_grid(dc)
        pen = wx.Pen(wx.BLACK)
        pen.SetWidth(1)
        pen.SetCap(wx.CAP_BUTT)
        dc.SetPen(pen)
        if self.kernel is None:
            return
        self.renderer.render(dc, self.kernel.draw_mode)
        if self.kernel.draw_mode & 32 == 0:
            self.on_draw_selection(dc, self.kernel.draw_mode)
        if self.kernel.draw_mode & 8 == 0:
            self.on_draw_laserpath(dc, self.kernel.draw_mode)

    def on_click_new(self, event):  # wxGlade: MeerK40t.<event_handler>
        self.working_file = None
        self.kernel.elements = LaserNode(parent=self.kernel)
        self.kernel.operations = []
        self.request_refresh()
        self.tree_update()
        # self.Refresh()

    def on_click_open(self, event):  # wxGlade: MeerK40t.<event_handler>
        # This code should load just specific project files rather than all importable formats.
        files = self.kernel.load_types()
        with wx.FileDialog(self, _("Open"), wildcard=files,
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            result = self.kernel.load(pathname)
            self.kernel.classify(result)

    def on_click_save(self, event):
        if self.working_file is None:
            self.on_click_save_as(event)
        else:
            self.kernel.save(self.working_file)

    def on_click_save_as(self, event):
        files = self.kernel.save_types()
        with wx.FileDialog(self, "Save Project", wildcard=files,
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            if not pathname.lower().endswith('.svg'):
                pathname += '.svg'
            self.kernel.save(pathname)
            self.working_file = pathname

    def on_click_exit(self, event):  # wxGlade: MeerK40t.<event_handler>
        self.Close()

    def on_click_zoom_out(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoomout button press
        """
        m = self.scene.ClientSize / 2
        self.scene_post_scale(1.0 / 1.5, 1.0 / 1.5, m[0], m[1])
        self.request_refresh()

    def on_click_zoom_in(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoomin button press
        """
        m = self.scene.ClientSize / 2
        self.scene_post_scale(1.5, 1.5, m[0], m[1])
        self.request_refresh()

    def on_click_zoom_size(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Zoom size button press.
        """
        self.focus_on_project()

    def toggle_draw_mode(self, bits):
        """
        Toggle the draw mode.
        :param bits: Bit to toggle.
        :return: Toggle function.
        """

        def toggle(event):
            self.kernel.draw_mode ^= bits
            self.request_refresh()

        return toggle

    def open_speedcode_gear_dialog(self):
        dlg = wx.TextEntryDialog(self, _("Enter Forced Gear"), _("Gear Entry"), '')
        dlg.SetValue('')

        if dlg.ShowModal() == wx.ID_OK:
            value = dlg.GetValue()
            if value in ('0', '1', '2', '3', '4'):
                self.kernel._stepping_force = int(value)
            else:
                self.kernel._stepping_force = None
        dlg.Destroy()

    def open_fps_dialog(self):
        dlg = wx.TextEntryDialog(self, _("Enter FPS Limit"), _("FPS Limit Entry"), '')
        dlg.SetValue('')

        if dlg.ShowModal() == wx.ID_OK:
            fps = dlg.GetValue()
            try:
                self.set_fps(int(fps))
            except ValueError:
                pass
        dlg.Destroy()

    def open_path_dialog(self):
        dlg = wx.TextEntryDialog(self, _("Enter SVG Path Data"), _("Path Entry"), '')
        dlg.SetValue('')

        if dlg.ShowModal() == wx.ID_OK:
            path = Path(dlg.GetValue())
            path.fill = 'black'
            path.stroke = 'black'
            group = LaserNode()
            group.name = 'Path'
            self.kernel.elements.append(group)

            p = abs(path)
            self.kernel.operations.append(EngraveOperation(p))
            group.append(LaserNode(p))
        dlg.Destroy()

    def open_preferences(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open preference dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Preferences")

    def open_rotary(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open rotary dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Rotary")

    def open_alignment(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Alignment Ally dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Alignment")

    def open_keymap(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Keymap dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Keymap")

    def open_colordefine(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open ColorDefine dialog

        :param event:
        :return:
        """
        self.kernel.open_window("ColorDefine")

    def open_usb(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open USB Log dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("UsbConnect")

    def open_navigation(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Navigation dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Navigation")

    def open_controller(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Controller dialog.

        :param event:
        :return:
        """
        self.kernel.open_window("Controller")

    def open_spooler(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Open Job Spooler.

        :param event:
        :return:
        """
        self.kernel.open_window("JobSpooler")

    def open_job(self, event=None):
        """
        Open Execute Job dialog.

        :param event:
        :return:
        """
        window = self.kernel.open_window("JobInfo")

        window.set_elements(self.kernel.operations[:])

    def launch_webpage(self, event):  # wxGlade: MeerK40t.<event_handler>
        """
        Launch webpage

        :param event:
        :return:
        """
        import webbrowser
        webbrowser.open(MEERK40T_WEBSITE, new=0, autoraise=True)

    def language_swap(self, lang):
        def update(event):
            self.Unbind(wx.EVT_CLOSE, self)
            self.language_to(lang)
            self.kernel.flush()
            self.Close(True)
            window = MeerK40t(None, wx.ID_ANY, "")
            window.Show()

        return update

    def language_to(self, lang):
        """
        Returns a function to change the language to the language specified.
        :param lang: language to switch to
        :return:
        """

        def update_language(event):
            """
            Update language to the requested language.
            """
            language_code, language_name, language_index = supported_languages[lang]
            self.kernel.language = lang

            if self.locale:
                assert sys.getrefcount(self.locale) <= 2
                del self.locale
            self.locale = wx.Locale(language_index)
            if self.locale.IsOk():
                self.locale.AddCatalog('meerk40t')
            else:
                self.locale = None
            self.kernel('language', (lang, language_code, language_name, language_index))

        return update_language


    def create_menu(self, element):
        """Create menu items. This is used for both the scene and the tree to create menu items."""
        if element is None:
            return
        gui = self
        menu = wx.Menu()
        if isinstance(element, LaserNode):
            t = element.type
            if t != 'root':
                gui.Bind(wx.EVT_MENU, self.menu_remove(element),
                         menu.Append(wx.ID_ANY, _("Remove %s") % str(element)[:16], "", wx.ITEM_NORMAL))
                if t == 'group':
                    fpath = element['filepath']
                    if fpath is not None:
                        name = os.path.basename(fpath)
                        gui.Bind(wx.EVT_MENU, self.menu_reload(element),
                                 menu.Append(wx.ID_ANY, _("Reload %s") % name, "", wx.ITEM_NORMAL))
                        if len(element) > 1:
                            gui.Bind(wx.EVT_MENU, self.menu_reverse_order(element),
                                     menu.Append(wx.ID_ANY, _("Reverse Layer Order"), "", wx.ITEM_NORMAL))
                else:
                    if element.passes != 1:
                        gui.Bind(wx.EVT_MENU, self.menu_split_passes(element),
                                 menu.Append(wx.ID_ANY, _("Split Passes"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_hull(element), menu.Append(wx.ID_ANY, _("Convex Hull"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_execute(element), menu.Append(wx.ID_ANY, _("Execute Job"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_reset(element),
                         menu.Append(wx.ID_ANY, _("Reset User Changes"), "", wx.ITEM_NORMAL))
                path_scale_sub_menu = wx.Menu()
                for i in range(1, 25):
                    gui.Bind(wx.EVT_MENU, self.menu_scale(element, 6.0 / float(i)),
                             path_scale_sub_menu.Append(wx.ID_ANY, _("Scale %.0f%%" % (600.0 / float(i))), "", wx.ITEM_NORMAL))
                menu.AppendSubMenu(path_scale_sub_menu, _("Scale"))
                path_rotate_sub_menu = wx.Menu()
                for i in range(2, 13):
                    angle = Angle.turns(1.0 / float(i))
                    gui.Bind(wx.EVT_MENU, self.menu_rotate(element, 1.0 / float(i)),
                             path_rotate_sub_menu.Append(wx.ID_ANY, _(u"Rotate turn/%d, %.0f°" % (i, angle.as_degrees)), "",
                                                         wx.ITEM_NORMAL))
                for i in range(2, 13):
                    angle = Angle.turns(1.0 / float(i))
                    gui.Bind(wx.EVT_MENU, self.menu_rotate(element, -1.0 / float(i)),
                             path_rotate_sub_menu.Append(wx.ID_ANY, _(u"Rotate turn/%d, -%.0f°" % (i, angle.as_degrees)), "",
                                                         wx.ITEM_NORMAL))
                menu.AppendSubMenu(path_rotate_sub_menu, _("Rotate"))
            if element.contains_type('path'):
                vector_menu = wx.Menu()
                gui.Bind(wx.EVT_MENU, self.menu_subpath(element),
                         vector_menu.Append(wx.ID_ANY, _("Break Subpaths"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_raster(element),
                         vector_menu.Append(wx.ID_ANY, _("Make Raster Image"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_reify(element),
                         menu.Append(wx.ID_ANY, _("Reify User Changes"), "", wx.ITEM_NORMAL))
                menu.AppendSubMenu(vector_menu, _("Vector"))
            if element.contains_type('image'):
                image_menu = wx.Menu()
                gui.Bind(wx.EVT_MENU, self.menu_raster_actualize(element),
                         image_menu.Append(wx.ID_ANY, _("Actualize Pixels"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_dither(element),
                         image_menu.Append(wx.ID_ANY, _("Dither to 1 bit"), "", wx.ITEM_NORMAL))
                gui.Bind(wx.EVT_MENU, self.menu_raster_native(element),
                         image_menu.Append(wx.ID_ANY, _("Set to Native"), "", wx.ITEM_NORMAL))
                image_sub_menu_step = wx.Menu()
                for i in range(1, 8):
                    gui.Bind(wx.EVT_MENU, self.menu_step(element, i),
                             image_sub_menu_step.Append(wx.ID_ANY, _("Step %d") % i, "", wx.ITEM_NORMAL))
                image_menu.AppendSubMenu(image_sub_menu_step, _("Step"))
                menu.AppendSubMenu(image_menu, _("Raster"))
            if element.contains_type('text'):
                text_menu = wx.Menu()
                gui.Bind(wx.EVT_MENU, self.menu_remove(element, types=(SVGText)),
                         text_menu.Append(wx.ID_ANY, _("Remove Text"), "", wx.ITEM_NORMAL))
                menu.AppendSubMenu(text_menu, _("Text"))
        elif isinstance(element, LaserOperation):
            gui.Bind(wx.EVT_MENU, self.menu_remove(element),
                     menu.Append(wx.ID_ANY, _("Remove %s") % str(element)[:16], "", wx.ITEM_NORMAL))
        if menu.MenuItemCount != 0:
            gui.PopupMenu(menu)
            menu.Destroy()

    def menu_scale(self, element, value):
        """
        Menu scale.

        :param element:
        :param value:
        :return:
        """

        def specific(event):
            center = element.center
            if center is not None:
                for e in element.flat_elements(types=('image', 'path', 'text'), passes=False):
                    e.element.transform.post_scale(value, value, center[0], center[1])
                self.kernel("elements", 0)

        return specific


    def menu_step(self, element, step_value):
        """
        Change raster step values of subelements.

        :param element:
        :param step_value:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('image'), passes=False):
                old_step = e.raster_step
                e.raster_step = step_value
                scale = float(step_value) / float(old_step)
                m = e.transform
                e.transform.post_scale(scale, scale, m.e, m.f)
            self.kernel("elements", 0)

        return specific


    def menu_raster_actualize(self, element):
        """
        Causes the raster image to be native at the current scale by rotating, scaling, skewing etc.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('image'), passes=False):
                e.make_actual()
            self.kernel(_("elements"), 0)

        return specific


    def menu_raster_native(self, element):
        """
        Reset the raster to native form validating the matrix for the given step value.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('image'), passes=False):
                e.set_native()
            self.kernel("elements", 0)

        return specific


    def menu_dither(self, element):
        """
        Change raster dither forcing raster elements to 1 bit.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('image'), passes=False):
                e.element.image = e.element.image.convert("1")
                e.cache = None
            self.kernel("elements", 0)

        return specific


    def menu_raster(self, element):
        """
        Convert a vector element into a raster element.

        :param element:
        :return:
        """

        def specific(event):
            renderer = LaserRender(self.kernel)
            image = renderer.make_raster(element, types='path')
            xmin, ymin, xmax, ymax = self.kernel.selected.scene_bounds
            image_element = LaserNode(SVGImage(image=image))
            self.kernel.selected.append(image_element)
            image_element.element.transform.post_translate(xmin, ymin)
            self.kernel("elements", 0)

        return specific

    def menu_reify(self, element):
        """
        Reify elements so that the translations apply direct to the object.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('path'), passes=False):
                e.reify_matrix()
                self.kernel("elements", 0)

        return specific

    def menu_reset(self, element):
        """
        Menu to reset transformations applied to elements.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.flat_elements(types=('image', 'path', 'text'), passes=False):
                e.element.transform.reset()
                self.kernel("elements", 0)

        return specific

    def menu_rotate(self, element, value):
        """
        Menu to rotate an element.

        :param element:
        :param value:
        :return:
        """

        value *= tau

        def specific(event):
            center = element.center
            for e in element.flat_elements(types=('image', 'path', 'text'), passes=False):
                e.transform.post_rotate(value, center[0], center[1])
            self.kernel("elements", 0)

        return specific

    def menu_reload(self, element):
        """
        Menu to reload the element from the file on disk.

        :param element:
        :return:
        """

        filepath = element['filepath']

        def specific(event):
            for e in reversed(element):
                e.detach()
            self.kernel.load(filepath, group=element)

        return specific

    def menu_remove(self, element, types=None):
        """
        Menu to remove an element from the scene.

        :param element:
        :return:
        """
        if isinstance(element, LaserNode):
            def delete_element(event):
                if types is None:
                    try:
                        element.parent.remove(element)
                    except AttributeError:
                        pass
                    self.kernel.set_selected(None)
                else:
                    for e in element.all_children_of_type(types=types):
                        try:
                            e.parent.remove(e)
                        except AttributeError:
                            pass
                    self.kernel.set_selected(None)
        else:
            def delete_element(event):
                self.kernel.operations.remove(element)
                self.kernel("elements",0)

        return delete_element

    def menu_split_passes(self, element):
        """
        Menu to break element into subpath.

        :param element:
        :return:
        """

        def specific(event):
            for e in element.all_children_of_type(types=('path', 'image', 'text')):
                if e.passes != 1:
                    parent = e.parent
                    position = parent.index(e)
                    e.detach()
                    passes = e.passes
                    e.passes = 1
                    all = []
                    for i in range(0, passes):
                        all.append(LaserNode(e))
                    parent.insert_all(position, all)
            self.kernel("elements", 0)
            self.kernel.set_selected(None)

        return specific

    def menu_subpath(self, element):
        """
        Menu to break element into subpath.

        :param element:
        :return:
        """

        def specific(event):
            context = element
            for e in element.all_children_of_type(types=('path')):
                e.detach()
                p = abs(e.element)
                add = []
                for subpath in p.as_subpaths():
                    subelement = LaserNode(Path(subpath))
                    subelement.element.values.update(e.element.values)
                    add.append(subelement)
                context.append_all(add)
            self.kernel("elements", 0)
            self.kernel.set_selected(None)

        return specific

    def menu_execute(self, element):
        """
        Menu to launch Execute Job for the particular element.

        :param element:
        :return:
        """

        def open_jobinfo_window(event):
            window = self.kernel.open_window("JobInfo")
            window.set_elements([e for e in element.flat_elements(types=('image', 'path', 'text'), passes=True)])

        return open_jobinfo_window


    def get_convex_hull(self, element):
        """
        Processing function for menu_hull(element) to return the hull points.

        :param element:
        :return:
        """
        pts = []
        for e in element.flat_elements(types=('image', 'path'), passes=False):
            if isinstance(e.element, Path):
                epath = abs(e.element)
                pts += [q for q in epath.as_points()]
            elif isinstance(e.element, SVGImage):
                bounds = e.scene_bounds
                pts += [(bounds[0], bounds[1]), (bounds[0], bounds[3]), (bounds[2], bounds[1]), (bounds[2], bounds[3])]
        hull = [p for p in Point.convex_hull(pts)]
        if len(hull) == 0:
            return None
        return hull


    def menu_hull(self, element):
        """
        Menu to return and add the convex hull of the element to the scene.

        :param element:
        :return:
        """

        def convex_hull(event):
            path = Path()
            pts = self.get_convex_hull(element)
            if pts is None:
                return
            path.move(*pts)
            path.closed()
            path.stroke = Color('black')
            context = element.parent
            context.append(LaserNode(path))
            self.kernel.set_selected(None)

        return convex_hull


    def menu_reverse_order(self, element):
        """
        Menu to return and add the convex hull of the element to the scene.

        :param element:
        :return:
        """

        def specific(event):
            element.reverse()
            self.kernel("elements", 0)

        return specific


class MappedKey:
    """
    Mapped key class containing the key and the command.
    """

    def __init__(self, key, command):
        self.key = key
        self.command = command

    def __str__(self):
        return self.key


class wxMeerK40t(Module, wx.App):
    """
    wxMeerK40t is the wx.App main class and a qualified Module for the MeerK40t kernel.
    Running MeerK40t without the wxMeerK40t gui is both possible and reasonable. This should not change the way the
    underlying code runs. It should just be a series of frames held together with the kernel.
    """

    def __init__(self):
        wx.App.__init__(self,0)
        Module.__init__(self)
        self.locale = None
        self.kernel = None

    def OnInit(self):
        return True

    def initialize(self, kernel, name=None):
        kernel.setting(wx.App, 'gui', self) # Registers self as kernel.gui
        kernel.add_window("MeerK40t", MeerK40t)
        self.kernel = kernel
        _ = wx.GetTranslation

        wx.Locale.AddCatalogLookupPathPrefix('locale')

        kernel.run_later = wx.CallAfter
        kernel.translation = wx.GetTranslation
        kernel.set_config(wx.Config("MeerK40t"))
        kernel.setting(int, 'language', None)

        kernel.add_window('ElementProperty', ElementProperty)
        kernel.add_window('Controller', Controller)
        kernel.add_window("Preferences", Preferences)
        kernel.add_window("Rotary", RotarySettings)
        kernel.add_window("Alignment", Alignment)
        kernel.add_window("Keymap", Keymap)
        kernel.add_window("ColorDefine", ColorDefine)
        kernel.add_window("UsbConnect", UsbConnect)
        kernel.add_window("Navigation", Navigation)
        kernel.add_window("Controller", Controller)
        kernel.add_window("JobSpooler", JobSpooler)
        kernel.add_window("JobInfo", JobInfo)
        kernel.add_window("BufferView", BufferView)
        language = kernel.language
        if language is not None and language != 0:
            self.language_to(language)(None)
        self.kernel.open_window("MeerK40t")


# end of class MeerK40tGui
def handleGUIException(exc_type, exc_value, exc_traceback):
    """
    Handler for errors. Save error to a file, and create dialog.

    :param exc_type:
    :param exc_value:
    :param exc_traceback:
    :return:
    """
    err_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
    print(err_msg)
    try:
        import datetime
        filename = "MeerK40t-{date:%Y-%m-%d_%H_%M_%S}.txt".format(date=datetime.datetime.now())
        print(_("Saving Log: %s" % filename))
        with open(filename, "w") as file:
            file.write(_("MeerK40t crash log. Version: %s\n" % MEERK40T_VERSION))
            file.write(("Please report to: %s\n\n" % MEERK40T_ISSUES))
            file.write(err_msg)
            print(file)
    except:  # I already crashed once, if there's another here just ignore it.
        pass
    dlg = wx.MessageDialog(None, err_msg, _('Error encountered'), wx.OK | wx.ICON_ERROR)
    dlg.ShowModal()
    dlg.Destroy()

sys.excepthook = handleGUIException
